<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>é›™æ¬„å¼é»‘è† æ’­æ”¾å™¨</title>
<style>
  :root {
    --bg-color: #0f0f0f;
    --player-bg: #212121;
    --list-hover: #2a2a2a;
    --list-active: #333333;
    --accent-color: #d4af37;
    --text-primary: #ffffff;
    --text-secondary: #aaaaaa;
  }

  body {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    background-color: var(--bg-color);
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    color: var(--text-primary);
  }

  /* --- éŒ¯èª¤æç¤ºæ¡† (Toast) --- */
  #toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #ff4444;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: bold;
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  }
  #toast.show {
    opacity: 1;
  }

  /* --- æ•´é«”ç‰ˆé¢é…ç½® --- */
  .app-container {
    display: flex;
    flex-direction: row;
    gap: 40px;
    width: 100%;
    max-width: 1000px;
    padding: 20px;
  }

  .player-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
    max-width: 400px;
  }

  .track-info {
    text-align: center;
    margin-bottom: 20px;
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.3s ease;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
  }
  .track-info.fading { opacity: 0; }
  .track-title { font-size: 22px; font-weight: bold; margin: 0; color: var(--text-primary); line-height: 1.4; }

  /* é»‘è† åº•åº§èˆ‡å‹•ç•« */
  .turntable {
    position: relative;
    width: 350px;
    height: 350px;
    background: var(--player-bg);
    border-radius: 20px;
    box-shadow: 10px 10px 30px rgba(0, 0, 0, 0.6), inset 2px 2px 5px rgba(255, 255, 255, 0.05);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 25px;
    overflow: hidden;
  }

  .record-wrapper {
    position: absolute;
    width: 300px;
    height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease;
    transform: translateX(0) scale(1);
    opacity: 1;
  }
  .record-wrapper.slide-out { transform: translateX(-120%) scale(0.8); opacity: 0; transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease; }
  .record-wrapper.ready-to-slide-in { transition: none !important; transform: translateX(120%) scale(0.8); opacity: 0; }

  .record {
    position: relative;
    width: 100%;
    height: 100%;
    background: #111;
    border-radius: 50%;
    background-image: repeating-radial-gradient(#111, #111 4px, #1a1a1a 5px, #111 6px);
    box-shadow: 0 0 15px rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: spin 3s linear infinite;
    animation-play-state: paused;
  }
  .record.playing { animation-play-state: running; }
  @keyframes spin { 100% { transform: rotate(360deg); } }

  .label {
    width: 100px;
    height: 100px;
    background-color: #333;
    background-size: cover;
    background-position: center;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    border: 2px solid var(--accent-color);
    transition: background-image 0.2s ease;
  }
  .hole { position: absolute; width: 12px; height: 12px; background: var(--player-bg); border-radius: 50%; box-shadow: inset 0 2px 4px rgba(0,0,0,0.6); }

  .tonearm {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 80px;
    height: 200px;
    transform-origin: 30px 30px; 
    transform: rotate(-15deg);
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 10;
  }
  .tonearm.playing { transform: rotate(25deg); }
  .pivot { position: absolute; top: 10px; left: 10px; width: 40px; height: 40px; border-radius: 50%; background: radial-gradient(circle, #d0d0d0, #666); box-shadow: 0 4px 8px rgba(0,0,0,0.6); }
  .arm { position: absolute; top: 30px; left: 26px; width: 8px; height: 140px; background: linear-gradient(to right, #ccc, #fff, #999); border-radius: 4px; }
  .headshell { position: absolute; top: 160px; left: 14px; width: 20px; height: 35px; background: #222; border-radius: 3px; transform: rotate(25deg); box-shadow: 2px 2px 5px rgba(0,0,0,0.5); }

  /* é€²åº¦æ¢å€åŸŸ */
  .progress-wrapper { width: 350px; margin-top: 10px; margin-bottom: 25px; display: flex; flex-direction: column; gap: 12px; }
  .progress-container { width: 100%; height: 6px; background-color: #444; border-radius: 3px; cursor: pointer; position: relative; padding: 10px 0; margin: -10px 0; background-clip: content-box; }
  .progress-bar { position: absolute; top: 10px; left: 0; height: 6px; background-color: var(--accent-color); width: 0%; border-radius: 3px; pointer-events: none; }
  .progress-thumb { position: absolute; top: 13px; left: 0%; transform: translate(-50%, -50%); width: 14px; height: 14px; background-color: var(--accent-color); border-radius: 50%; opacity: 0; transition: opacity 0.2s ease; pointer-events: none; }
  .progress-tooltip { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(30, 30, 30, 0.9); border: 1px solid #444; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; opacity: 0; transition: opacity 0.2s ease; white-space: nowrap; pointer-events: none; font-variant-numeric: tabular-nums; }
  .progress-container:hover .progress-thumb, .progress-container.dragging .progress-thumb { opacity: 1; }
  .progress-container.dragging .progress-tooltip { opacity: 1; }
  .progress-container:not(.dragging) .progress-bar, .progress-container:not(.dragging) .progress-thumb { transition: width 0.1s linear, left 0.1s linear; }
  .time-info { display: flex; justify-content: space-between; font-size: 13px; color: var(--text-secondary); font-variant-numeric: tabular-nums; }

  /* æ§åˆ¶æŒ‰éˆ• */
  .controls { display: flex; gap: 40px; align-items: center; justify-content: center; margin-top: 10px; }
  .controls button { background: transparent; border: none; padding: 0; color: var(--text-primary); cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; display: flex; align-items: center; justify-content: center; }
  .controls button svg { fill: currentColor; width: 32px; height: 32px; }
  .controls #toggleBtn svg { width: 52px; height: 52px; }
  .controls button:hover:not(:disabled) { transform: scale(1.1); }
  .controls button:active:not(:disabled) { transform: scale(0.95); }
  .controls button:disabled { opacity: 0.3; cursor: not-allowed; }

  /* å³å´æ¸…å–® */
  .playlist-section { flex: 1; background: #000000; border-radius: 12px; display: flex; flex-direction: column; overflow: hidden; height: 600px; border: 1px solid #333; }
  .playlist-header { display: flex; padding: 0 20px; border-bottom: 1px solid #333; background: #111; }
  .playlist-tab { padding: 15px 20px; font-size: 15px; color: var(--text-primary); font-weight: bold; border-bottom: 2px solid var(--text-primary); }
  .playlist-items { flex: 1; overflow-y: auto; padding: 10px 0; margin: 0; list-style: none; }
  .playlist-items::-webkit-scrollbar { width: 8px; }
  .playlist-items::-webkit-scrollbar-track { background: transparent; }
  .playlist-items::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
  .playlist-items::-webkit-scrollbar-thumb:hover { background: #777; }
  .playlist-item { display: flex; align-items: center; padding: 10px 20px; gap: 15px; cursor: pointer; transition: background 0.2s; }
  .playlist-item:hover { background-color: var(--list-hover); }
  .playlist-item.active { background-color: var(--list-active); }
  .playlist-item img { width: 40px; height: 40px; border-radius: 4px; object-fit: cover; }
  .playlist-item .item-info { flex: 1; overflow: hidden; display: flex; flex-direction: column; gap: 4px; }
  .playlist-item .item-title { font-size: 14px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .playlist-item.active .item-title { color: var(--accent-color); font-weight: bold; }
  .playlist-item .item-artist { font-size: 12px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .item-source-badge { font-size: 11px; padding: 2px 6px; border-radius: 4px; background: #333; color: #aaa; }

  @media (max-width: 768px) {
    .app-container { flex-direction: column; align-items: center; }
    .player-section { margin-bottom: 20px; }
    .playlist-section { width: 100%; max-width: 400px; height: 400px; }
  }

  /* ã€å„ªåŒ–ã€‘YouTube éš±è—æ’­æ”¾å™¨ï¼Œæ”¹æ”¾ç•«é¢æ­£ä¸­å¤®åº•å±¤ï¼Œé˜²ç€è¦½å™¨ç¯€æµ */
  #ytplayer-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 200px;
    z-index: -100;
    opacity: 0.01; 
    pointer-events: none;
  }
</style>
</head>
<body>

  <!-- éŒ¯èª¤æç¤ºæ¡† -->
  <div id="toast">éŒ¯èª¤æç¤º</div>

  <div class="app-container">
    
    <!-- å·¦å´æ’­æ”¾å™¨ -->
    <div class="player-section">
      <div class="track-info" id="trackInfoBox">
        <p class="track-title" id="trackTitle">è¼‰å…¥æ’è¡Œæ¦œä¸­...</p>
      </div>

      <div class="turntable">
        <div class="record-wrapper" id="recordWrapper">
          <div class="record" id="record">
            <div class="label" id="recordLabel">
              <div class="hole"></div>
            </div>
          </div>
        </div>
        <div class="tonearm" id="tonearm">
          <div class="pivot"></div>
          <div class="arm"></div>
          <div class="headshell"></div>
        </div>
      </div>

      <!-- æ‹–æ›³å¼é€²åº¦æ¢ -->
      <div class="progress-wrapper">
        <div class="progress-container" id="progressContainer">
          <div class="progress-bar" id="progressBar"></div>
          <div class="progress-thumb" id="progressThumb">
             <div class="progress-tooltip" id="progressTooltip">0:00</div>
          </div>
        </div>
        <div class="time-info">
          <span id="currentTime">0:00</span>
          <span id="durationTime">è¼‰å…¥ä¸­</span>
        </div>
      </div>

      <div class="controls">
        <button id="prevBtn" disabled>
          <svg viewBox="0 0 24 24"><rect x="5" y="6" width="2" height="12" /><polygon points="18,6 7,12 18,18" /></svg>
        </button>
        <button id="toggleBtn" disabled>
          <svg id="playIcon" viewBox="0 0 24 24"><polygon points="6,4 21,12 6,20" /></svg>
          <svg id="pauseIcon" viewBox="0 0 24 24" style="display: none;"><rect x="5" y="4" width="5" height="16" /><rect x="14" y="4" width="5" height="16" /></svg>
        </button>
        <button id="nextBtn" disabled>
          <svg viewBox="0 0 24 24"><polygon points="6,6 17,12 6,18" /><rect x="17" y="6" width="2" height="12" /></svg>
        </button>
      </div>
    </div>

    <!-- å³å´æ’­æ”¾æ¸…å–® -->
    <div class="playlist-section">
      <div class="playlist-header">
        <div class="playlist-tab active">å³å°‡æ’­æ”¾</div>
      </div>
      <ul class="playlist-items" id="playlistContainer">
        <!-- æ­Œæ›²é …ç›®å‹•æ…‹ç”Ÿæˆ -->
      </ul>
    </div>

  </div>

  <audio id="bgMusic"></audio>
  
  <div id="ytplayer-container">
    <div id="ytplayer"></div>
  </div>

  <script>
    // ==========================================
    // ğŸ”‘ é›™å¼•æ“æ ¸å¿ƒè¨­å®š (YouTube API)
    // ==========================================
    const YOUTUBE_API_KEY = 'AIzaSyBZSUuA-unnlexX-cbp7j-BbECcpZ6absk'; // ã€è«‹åœ¨æ­¤å¡«å…¥ä½ çš„é‡‘é‘°ã€‘
    
    let ytPlayer;
    let isYtReady = false;
    let currentPlayMode = 'apple'; 
    let ytPlayerErrorCount = 0; // è¿½è¹¤ YT é€£çºŒéŒ¯èª¤æ¬¡æ•¸

    // é¡¯ç¤ºæç¤ºè¨Šæ¯çš„å‡½æ•¸
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 4000);
    }

    const tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    function onYouTubeIframeAPIReady() {
        ytPlayer = new YT.Player('ytplayer', {
            height: '200',
            width: '200',
            playerVars: { 
              'autoplay': 0, 
              'controls': 0, 
              'playsinline': 1,
              // é˜²æ²» file:// å”å®šéŒ¯èª¤
              'origin': window.location.protocol === 'file:' ? '*' : window.location.origin 
            },
            events: {
                'onReady': () => { 
                  isYtReady = true; 
                  console.log("YT æ’­æ”¾å™¨åˆå§‹åŒ–æˆåŠŸ"); 
                },
                'onStateChange': onYtStateChange,
                'onError': onYtError
            }
        });
    }

    function onYtError(event) {
        let errorMsg = "YouTube å½±ç‰‡ç„¡æ³•æ’­æ”¾";
        if(event.data === 101 || event.data === 150) errorMsg = "é€™é¦– YouTube æ­Œæ›²ç¦æ­¢åœ¨å¤–éƒ¨ç¶²ç«™æ’­æ”¾";
        if(event.data === 2) errorMsg = "YouTube æ‰¾ä¸åˆ°æ­¤å½±ç‰‡åƒæ•¸";
        
        console.warn(errorMsg, event.data);
        showToast(errorMsg + "ï¼Œå·²é™ç´šç‚º Apple é è¦½ç‰ˆ");
        
        currentPlayMode = 'apple';
        bgMusic.src = playlist[currentTrackIndex].audioUrl;
        
        renderPlaylist();
        durationTimeEl.textContent = '0:30';
        
        if (isPlaying) {
            bgMusic.play().catch(e => console.log("éœ€è¦ä½¿ç”¨è€…äº’å‹•æ‰èƒ½æ’­æ”¾", e));
        }
    }

    function onYtStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            const duration = ytPlayer.getDuration();
            if (duration > 0) durationTimeEl.textContent = formatTime(duration);
        }
        
        if (event.data === YT.PlayerState.ENDED) {
            if (document.hidden) changeTrackInstant();
            else changeTrackAnimated();
        }
    }

    const recordWrapper = document.getElementById('recordWrapper');
    const record = document.getElementById('record');
    const recordLabel = document.getElementById('recordLabel');
    const tonearm = document.getElementById('tonearm');
    
    const prevBtn = document.getElementById('prevBtn');
    const toggleBtn = document.getElementById('toggleBtn');
    const nextBtn = document.getElementById('nextBtn');
    const playIcon = document.getElementById('playIcon');
    const pauseIcon = document.getElementById('pauseIcon');
    
    const bgMusic = document.getElementById('bgMusic');
    const trackInfoBox = document.getElementById('trackInfoBox');
    const trackTitle = document.getElementById('trackTitle');
    
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressThumb = document.getElementById('progressThumb');
    const progressTooltip = document.getElementById('progressTooltip');
    const currentTimeEl = document.getElementById('currentTime');
    const durationTimeEl = document.getElementById('durationTime');
    const playlistContainer = document.getElementById('playlistContainer');

    let isPlaying = false;
    let playTimeout;
    let playlist = [];
    let currentTrackIndex = 0;
    let isAnimating = false;
    let isDragging = false;

    function formatTime(seconds) {
      if (isNaN(seconds) || seconds === Infinity || seconds === 0) return "0:00";
      const min = Math.floor(seconds / 60);
      const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
      return `${min}:${sec}`;
    }

    async function fetchTopSongs() {
      try {
        const response = await fetch('https://itunes.apple.com/tw/rss/topsongs/limit=15/json');
        if (!response.ok) throw new Error('ç¶²è·¯å›æ‡‰éŒ¯èª¤');
        const data = await response.json();
        
        playlist = data.feed.entry.map(entry => {
          const audioLink = entry.link.find(l => l.attributes.type && l.attributes.type.includes('audio'));
          return {
            title: entry['im:name'].label,
            artist: entry['im:artist'].label,
            cover: entry['im:image'][2].label, 
            audioUrl: audioLink ? audioLink.attributes.href : ''
          };
        });
        
        prevBtn.disabled = false;
        toggleBtn.disabled = false;
        nextBtn.disabled = false;
        
        updateTrackUI(currentTrackIndex);
        renderPlaylist();
        
        // æª¢æŸ¥æ˜¯å¦åœ¨æœ¬åœ°æª”æ¡ˆç’°å¢ƒ
        if(window.location.protocol === 'file:') {
          showToast("æ³¨æ„ï¼šæ‚¨ç›®å‰ä½¿ç”¨æœ¬æ©Ÿæª”æ¡ˆ (file://) é–‹å•Ÿï¼ŒYouTube API å¯èƒ½æœƒè¢«ç€è¦½å™¨å®‰å…¨æ©Ÿåˆ¶é˜»æ“‹ã€‚å»ºè­°ä½¿ç”¨ Local Server é–‹å•Ÿã€‚");
        }

        loadAudioEngine(playlist[currentTrackIndex], false);

      } catch (error) {
        trackTitle.textContent = "ç„¡æ³•è¼‰å…¥æ­Œå–®ï¼Œè«‹æª¢æŸ¥ç¶²è·¯";
        console.error("API Error:", error);
      }
    }

    async function loadAudioEngine(track, shouldPlay) {
        bgMusic.pause();
        if(isYtReady && ytPlayer && ytPlayer.pauseVideo) ytPlayer.pauseVideo();
        
        if (YOUTUBE_API_KEY && YOUTUBE_API_KEY !== 'è«‹æ›¿æ›æˆä½ çš„æ–°é‡‘é‘°' && isYtReady) {
            try {
                const query = `${track.title} ${track.artist} audio`;
                const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&videoEmbeddable=true&key=${YOUTUBE_API_KEY}`;
                
                const res = await fetch(url);
                const data = await res.json();
                
                if (data.error) {
                    showToast(`YouTube API éŒ¯èª¤: ${data.error.message} (è«‹æª¢æŸ¥é‡‘é‘°æˆ–é…é¡)`);
                    throw new Error(data.error.message);
                }
                
                if (data.items && data.items.length > 0) {
                    const videoId = data.items[0].id.videoId;
                    currentPlayMode = 'youtube';
                    
                    if (shouldPlay) {
                        ytPlayer.loadVideoById(videoId); 
                    } else {
                        ytPlayer.cueVideoById(videoId);  
                    }
                    
                    renderPlaylist(); 
                    return; 
                } else {
                    showToast(`åœ¨ YouTube æ‰¾ä¸åˆ°ã€Œ${track.title}ã€çš„å¯ç”¨éŸ³æª”ï¼Œé™ç´šç‚º Apple é è¦½`);
                }
            } catch(e) {
                console.warn("YouTube è®€å–å¤±æ•—ï¼Œé™ç´šè‡³ Apple", e);
            }
        } else if (YOUTUBE_API_KEY === '' || YOUTUBE_API_KEY === 'è«‹æ›¿æ›æˆä½ çš„æ–°é‡‘é‘°') {
             // åªæœ‰ç¬¬ä¸€æ¬¡æ›æ­Œæ™‚æç¤ºæœªè¼¸å…¥é‡‘é‘°
             if (currentTrackIndex === 0) console.log("æœªè¼¸å…¥ YouTube API é‡‘é‘°ï¼Œä½¿ç”¨é è¦½æ¨¡å¼");
        }

        currentPlayMode = 'apple';
        bgMusic.src = track.audioUrl;
        durationTimeEl.textContent = '0:30';
        if (shouldPlay) {
            bgMusic.play().catch(e => console.log("ç­‰å¾…äº’å‹•", e));
        }
        renderPlaylist();
    }

    function renderPlaylist() {
      playlistContainer.innerHTML = '';
      playlist.forEach((track, index) => {
        const li = document.createElement('li');
        li.className = `playlist-item ${index === currentTrackIndex ? 'active' : ''}`;
        li.onclick = () => {
          if (index !== currentTrackIndex) changeTrackAnimated(index); 
        };
        
        let sourceBadge = '';
        if (index === currentTrackIndex) {
            sourceBadge = currentPlayMode === 'youtube' 
              ? `<span class="item-source-badge">å®Œæ•´ç‰ˆ (YT)</span>` 
              : `<span class="item-source-badge">30ç§’é è¦½</span>`;
        }

        li.innerHTML = `
          <img src="${track.cover}" alt="cover">
          <div class="item-info">
            <div class="item-title">${track.title}</div>
            <div class="item-artist">${track.artist}</div>
          </div>
          ${sourceBadge}
        `;
        playlistContainer.appendChild(li);
      });
      
      const activeItem = playlistContainer.querySelector('.active');
      if(activeItem) activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    function updateTrackUI(index) {
      if (!playlist[index]) return;
      const track = playlist[index];
      trackTitle.textContent = track.title;
      recordLabel.style.backgroundImage = `url('${track.cover}')`;
      
      progressBar.style.width = '0%';
      progressThumb.style.left = '0%';
      currentTimeEl.textContent = '0:00';
      durationTimeEl.textContent = 'è¼‰å…¥ä¸­...';
    }

    function togglePlayState() {
      if (!isPlaying) {
        isPlaying = true;
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
        
        // ã€é—œéµä¿®å¾©ã€‘ç›´æ¥åœ¨é»æ“Šçš„ç¬é–“è§¸ç™¼æ’­æ”¾ï¼Œç¹éç€è¦½å™¨è‡ªå‹•æ’­æ”¾é™åˆ¶
        if (currentPlayMode === 'youtube' && isYtReady) {
            ytPlayer.playVideo();
        } else {
            bgMusic.play().catch(e => showToast("ç€è¦½å™¨é˜»æ“‹è‡ªå‹•æ’­æ”¾ï¼Œè«‹é»æ“Šç•«é¢å†è©¦ä¸€æ¬¡"));
        }

        tonearm.classList.add('playing');
        playTimeout = setTimeout(() => {
          record.classList.add('playing');
        }, 300); 
      } else {
        isPlaying = false;
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
        
        clearTimeout(playTimeout);
        record.classList.remove('playing');
        tonearm.classList.remove('playing');
        
        if (currentPlayMode === 'youtube' && isYtReady) {
            ytPlayer.pauseVideo();
        } else {
            bgMusic.pause();
        }
      }
    }

    function changeTrackAnimated(targetIndex = null) {
        if (isAnimating || playlist.length === 0) return; 
        isAnimating = true;

        const wasPlaying = isPlaying;
        
        // ã€å„ªåŒ–ã€‘åˆ‡æ›æ­Œæ›²æ™‚å…ˆç«‹å³æš«åœï¼Œé¿å…è²éŸ³é‡ç–Š
        if (currentPlayMode === 'youtube' && isYtReady) ytPlayer.pauseVideo();
        else bgMusic.pause();

        if (isPlaying) togglePlayState(); // æ›´æ–° UI ç‹€æ…‹ç‚ºæš«åœ
        
        prevBtn.disabled = true;
        toggleBtn.disabled = true;
        nextBtn.disabled = true;
        trackInfoBox.classList.add('fading');

        setTimeout(() => {
            recordWrapper.classList.add('slide-out');
            setTimeout(() => {
                currentTrackIndex = targetIndex !== null ? targetIndex : (currentTrackIndex + 1) % playlist.length;
                
                updateTrackUI(currentTrackIndex);
                // åœ¨èƒŒæ™¯è¼‰å…¥æ–°æ­Œ
                loadAudioEngine(playlist[currentTrackIndex], false);

                recordWrapper.classList.remove('slide-out');
                recordWrapper.classList.add('ready-to-slide-in');

                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        recordWrapper.classList.remove('ready-to-slide-in');
                        trackInfoBox.classList.remove('fading');

                        setTimeout(() => {
                            isAnimating = false;
                            prevBtn.disabled = false;
                            toggleBtn.disabled = false;
                            nextBtn.disabled = false;
                            
                            // å‹•ç•«çµæŸï¼Œå¦‚æœåŸæœ¬åœ¨æ’­ï¼Œå°±ç¹¼çºŒæ’­æ”¾æ–°æ­Œ
                            if (wasPlaying || targetIndex !== null) {
                                if (!isPlaying) togglePlayState();
                            }
                        }, 600); 
                    });
                });
            }, 500); 
        }, 300);
    }

    function changeTrackInstant(targetIndex = null) {
        currentTrackIndex = targetIndex !== null ? targetIndex : (currentTrackIndex + 1) % playlist.length;
        updateTrackUI(currentTrackIndex);
        loadAudioEngine(playlist[currentTrackIndex], isPlaying);
        
        isAnimating = false;
        recordWrapper.classList.remove('slide-out', 'ready-to-slide-in');
        trackInfoBox.classList.remove('fading');
        prevBtn.disabled = false;
        toggleBtn.disabled = false;
        nextBtn.disabled = false;
    }

    function getCurrentDuration() {
        if (currentPlayMode === 'youtube' && isYtReady && ytPlayer.getDuration) {
            return ytPlayer.getDuration() || 0;
        }
        return bgMusic.duration || 0;
    }

    function updateProgressUI(clientX) {
      const duration = getCurrentDuration();
      if (!duration) return 0;
      
      const rect = progressContainer.getBoundingClientRect();
      let x = clientX - rect.left;
      x = Math.max(0, Math.min(x, rect.width));
      const percent = x / rect.width;
      
      progressBar.style.width = `${percent * 100}%`;
      progressThumb.style.left = `${percent * 100}%`;
      
      const targetTime = percent * duration;
      progressTooltip.textContent = formatTime(targetTime);
      currentTimeEl.textContent = formatTime(targetTime);

      return targetTime;
    }

    progressContainer.addEventListener('mousedown', (e) => {
      isDragging = true;
      progressContainer.classList.add('dragging');
      updateProgressUI(e.clientX);
    });
    window.addEventListener('mousemove', (e) => { if (isDragging) updateProgressUI(e.clientX); });
    window.addEventListener('mouseup', (e) => {
      if (isDragging) {
        isDragging = false;
        progressContainer.classList.remove('dragging');
        const targetTime = updateProgressUI(e.clientX);
        if (currentPlayMode === 'youtube' && isYtReady) ytPlayer.seekTo(targetTime, true);
        else bgMusic.currentTime = targetTime;
      }
    });

    progressContainer.addEventListener('touchstart', (e) => {
      isDragging = true;
      progressContainer.classList.add('dragging');
      updateProgressUI(e.touches[0].clientX);
    });
    window.addEventListener('touchmove', (e) => {
      if (isDragging) { e.preventDefault(); updateProgressUI(e.touches[0].clientX); }
    }, { passive: false });
    window.addEventListener('touchend', (e) => {
      if (isDragging) {
        isDragging = false;
        progressContainer.classList.remove('dragging');
        const targetTime = updateProgressUI(e.changedTouches[0].clientX);
        if (currentPlayMode === 'youtube' && isYtReady) ytPlayer.seekTo(targetTime, true);
        else bgMusic.currentTime = targetTime;
      }
    });

    function updateTimeLoop() {
        if (isPlaying && !isDragging) {
            let current = 0;
            let total = getCurrentDuration();
            
            if (currentPlayMode === 'youtube' && isYtReady && ytPlayer.getCurrentTime) {
                current = ytPlayer.getCurrentTime();
            } else if (currentPlayMode === 'apple') {
                current = bgMusic.currentTime;
            }

            if (total > 0) {
                const percent = (current / total) * 100;
                progressBar.style.width = `${percent}%`;
                progressThumb.style.left = `${percent}%`;
                currentTimeEl.textContent = formatTime(current);
                durationTimeEl.textContent = formatTime(total);
            }
        }
        requestAnimationFrame(updateTimeLoop);
    }
    requestAnimationFrame(updateTimeLoop); 

    toggleBtn.addEventListener('click', togglePlayState);
    nextBtn.addEventListener('click', () => changeTrackAnimated());
    prevBtn.addEventListener('click', () => {
      const prevIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
      changeTrackAnimated(prevIndex);
    });
    
    bgMusic.addEventListener('ended', () => {
        if (currentPlayMode === 'apple') {
            document.hidden ? changeTrackInstant() : changeTrackAnimated();
        }
    });

    fetchTopSongs();
  </script>

</body>
</html>